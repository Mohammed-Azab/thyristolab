\documentclass[11pt,a4paper]{article}

% ==================== PACKAGES ====================
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage{siunitx}
\usepackage{listings}

% ==================== CUSTOM COMMANDS ====================
\newcommand{\TODO}[1]{\textcolor{red}{\textbf{TODO: #1}}}

% ==================== LISTINGS SETUP ====================
\lstset{
    language=Matlab,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    tabsize=2,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    escapeinside={\%*}{*)},
    morekeywords={function, end, if, else, for, while, switch, case, otherwise}
}

% ==================== PAGE SETUP ====================
\geometry{
    a4paper,
    left=2.5cm,
    right=2.5cm,
    top=2.5cm,
    bottom=2.5cm
}

% ==================== HYPERLINKS ====================
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=cyan,
    citecolor=blue,
    pdftitle={Power Electronics I - Course Project},
    pdfauthor={Azab, Saber, Abdelhafez}
}

% ==================== GRAPHICS PATH ====================
\graphicspath{{figures/}}

% ==================== DOCUMENT BEGIN ====================
\begin{document}

% ==================== CUSTOM TITLE PAGE ====================
\begin{titlepage}
    \centering
    \vspace*{2cm}
    
    {\huge\bfseries Power Electronics I\par}
    \vspace{1cm}
    {\Large Course Project Report\par}
    \vspace{0.5cm}
    {\large Controlled Rectifiers for Battery Charging\par}
    
    \vspace{3cm}
    
    {\Large\textbf{Team Members}\par}
    \vspace{0.5cm}
    {\large
        Mohammed Azab\par
        \vspace{0.3cm}
        Basant Saber\par
        \vspace{0.3cm}
        Habiba Abdelhafez\par
    }
    
    \vfill
    
    {\large\textbf{German International University in Berlin}\par}
    {\large Faculty of Engineering\par}
    
    \vspace{1cm}
    
    {\large\textbf{Instructor:} Dr.-Ing. Moustafa Adly\par}
    
    \vspace{1cm}
    
    {\large Fall Semester 2025\par}
    {\large November 25, 2025\par}
    
\end{titlepage}

% Table of Contents
\tableofcontents
\newpage

% ==================== ABSTRACT ====================
\section*{Abstract}
\addcontentsline{toc}{section}{Abstract}

This project presents the design and analysis of controlled rectifier circuits using thyristors (SCRs) for battery charging applications. Three different rectifier configurations are implemented and simulated in MATLAB: half-wave controlled rectifier, full-wave center-tapped rectifier, and full-wave bridge rectifier. The study examines the relationship between firing angle and charging characteristics, including average and RMS voltage and current values. Performance comparisons demonstrate that full-wave configurations provide superior charging performance with reduced charging times and improved efficiency compared to half-wave rectifiers. The analysis includes circuit modeling, waveform generation, and comprehensive performance metrics for each topology.

% ==================== MAIN CONTENT ====================

% ==================== PART I ====================
\input{chapters/part1_introduction}
\input{chapters/part1_design}
\input{chapters/part1_results}
\input{chapters/part1_discussion}

% ==================== PART II ====================
\input{chapters/part2_introduction}
\input{chapters/part2_discussion}

% ==================== CONCLUSION ====================
\input{chapters/conclusion}

\newpage

% ==================== APPENDIX ====================
\appendix

\section{MATLAB Code}

This appendix contains the complete MATLAB implementation for the battery charger analysis.

\subsection{System Parameters (params.m)}

\begin{lstlisting}
% default battery_charger params

% Supply
Vrms = 230; 
f = 50;

% Battery
Vbat = 20; 
Rbat = 0.1; 
capacity = 50; 
capUnit = 'Ah';

% SoC & time
SoC_init = 12; 
SoC_target = 100;
t_charging_hours =  0.5; % Simulated User Input
t_charge = inf;

% Thyristor
alpha = 30;
alpha_deg = 0:2:180;         
Vt = 1.5;       
Rth = 0.001;  
Ileak = 0.01;  
t_rise = 1e-6;  
t_fall = 2e-6;  

% Simulation params 
dt = 1/(300*f);

% Visualization
enablePlots = true;
savePlots = true; 
\end{lstlisting}

\subsection{Half-Wave Rectifier (half\_wave\_charger.m)}

\begin{lstlisting}[basicstyle=\ttfamily\tiny]
function [alpha_deg, charging_time_hours, SoC_final, P_loss_avg, metrics] = half_wave_charger(Vrms, f, Vbat, Rbat, capacity, capUnit, varargin)
% Syntax:
%   [alpha_deg, charging_time_hours] = half_wave_charger(Vrms, f, Vbat, Rbat, capacity, capUnit)
%   [alpha_deg, charging_time_hours, SoC_final, P_loss_avg, metrics] = ...
%       half_wave_charger(..., 't_charge', t_charge, 'SoC_init', SoC_init, 'Vt', Vt, 'Rth', Rth)
%
% Inputs:
%   Vrms        - Supply voltage RMS value [V]
%   f           - Supply frequency [Hz]
%   Vbat        - Battery nominal voltage [V]
%   Rbat        - Battery internal resistance [Ohm]
%   capacity    - Battery capacity value
%   capUnit     - Battery capacity unit 'Ah' or 'Wh'
%
% Name-Value Optional Inputs:
%   't_charge'  - Charging time [Hours].
%   'SoC_init'  - Initial state of charge [%]
%   'Vt'        - Thyristor forward drop [V]
%   'Rth'       - Equivalent on-state resistance of thyristor [Ohm]
%   'Ileak'     - Reverse leakage Current [A]
%   't_rise'    - Rise time [s]
%   't_fall'    - Fall time[s]
%   'alpha_deg' - Vector of firing angles to analyze [deg] (for sweep analysis)
%   'alpha'     - Single firing angle [deg] (for detailed waveform plots)
%   'SoC_target'- Target state of charge [%]
%   'enablePlots'- Enable/disable all plots [boolean]
%
% Outputs:
%   alpha_deg           - Analyzed firing angles [deg] (vector)
%   charging_time_hours - Charging time for each alpha [h] (vector, same size as alpha_deg)
%   SoC_final           - Final SoC if 't_charge' provided [%] (vector)
%   P_loss_avg          - Average SCR conduction loss for each alpha [W] (vector)
%   metrics             - Struct with fields per alpha: Vavg, Vrms, Iavg, Irms,
%                         P_batt, P_thyristor, P_blocking, P_switching, P_total

% ---------- Load parameters from workspace ----------
try
    SoC_target_ws = evalin('base', 'SoC_target');
catch
    SoC_target_ws = 80; 
end
try
    t_charge_ws = evalin('base', 't_charge');
    if isinf(t_charge_ws)
        t_charge_ws = [];
    end
catch
    t_charge_ws = []; 
end
try
    alpha_deg_ws = evalin('base', 'alpha_deg');
catch
    alpha_deg_ws = 0:5:175;
end
try
    enablePlots_ws = evalin('base', 'enablePlots');
catch
    enablePlots_ws = false; 
end
try
    savePlots_ws = evalin('base', 'savePlots');
catch
    savePlots_ws = false;
end
try
    Rth_ws = evalin('base', 'Rth');
catch
    Rth_ws = 0;
end
try
    alpha_ws = evalin('base', 'alpha');
catch
    alpha_ws = 90;
end
try
    SoC_init_ws = evalin('base', 'SoC_init');
catch
    SoC_init_ws = 20;
end

% ---------- Parse inputs ----------
p = inputParser;
addParameter(p, 't_charge', t_charge_ws, @(x) isempty(x) || (isnumeric(x) && isscalar(x)));
addParameter(p, 'SoC_init', SoC_init_ws, @isnumeric);
addParameter(p, 'SoC_target', SoC_target_ws, @isnumeric);
addParameter(p, 'Vt', 0, @isnumeric);
addParameter(p, 'alpha_deg', alpha_deg_ws, @(x) isnumeric(x) && isvector(x));
addParameter(p, 'Rth', Rth_ws, @isnumeric);
addParameter(p, 'Ileak', 0, @isnumeric); 
addParameter(p, 't_rise', 0, @isnumeric); 
addParameter(p, 't_fall', 0, @isnumeric);
addParameter(p, 'alpha', alpha_ws, @isnumeric); 
addParameter(p, 'enablePlots', enablePlots_ws, @(x) islogical(x) || isnumeric(x));
addParameter(p, 'savePlots', savePlots_ws, @(x) islogical(x) || isnumeric(x));
parse(p, varargin{:});

t_charge      = p.Results.t_charge;
SoC_init      = p.Results.SoC_init;
SoC_target    = p.Results.SoC_target;
Vt            = p.Results.Vt;
alpha_deg     = p.Results.alpha_deg;
Rth           = p.Results.Rth;
Ileak         = p.Results.Ileak;
t_rise        = p.Results.t_rise;
t_fall        = p.Results.t_fall;
enablePlots   = logical(p.Results.enablePlots);
savePlots     = logical(p.Results.savePlots);
alpha         = p.Results.alpha;

if isstring(capUnit) || ischar(capUnit)
    if strcmpi(string(capUnit), "Wh")
        capacity = capacity / Vbat; % Wh -> Ah
    end
end

t_charge = t_charge*3600; % convert to Seconds

% ---------- Constants ----------
Vm = sqrt(2) * Vrms; % Peak voltage

% ---------- Sampling ----------
N = 4096;
theta = linspace(0, 2*pi, N+1); theta(end) = []; % exclude endpoint

% Half-wave: source voltage (positive half only, zero for negative)
V_source = Vm * sin(theta);
V_source(V_source < 0) = 0;  % Rectification

Q_C  = capacity * 3600;     % Ah -> Coulombs

% ---------- Outputs ----------
na = numel(alpha_deg);
Vavg = zeros(1, na);
Vout_rms = zeros(1, na);
Iavg = zeros(1, na);
Irms = zeros(1, na);
P_loss_avg = zeros(1, na);
P_batt = zeros(1, na);        % Battery internal losses
P_thyristor = zeros(1, na);   % Thyristor conduction losses
P_blocking = zeros(1, na);    % Thyristor blocking/leakage losses
P_switching = zeros(1, na);   % Thyristor switching losses
P_total = zeros(1, na);       % Total power losses
charging_time_hours = zeros(1, na);
SoC_final = zeros(1, na);

for k = 1:na
    a = deg2rad(alpha_deg(k));

    % Gate available only in positive half-cycle after firing angle
    gate = (theta >= a) & (theta <= pi);

    v_conv = V_source - Vt;
    v_conv(v_conv < 0) = 0;

    % Conduction only when above battery clamp
    cond  = v_conv > Vbat;

    i_t = zeros(size(theta));
    on  = gate & cond;
    i_t(on) = (v_conv(on) - Vbat) ./ Rbat;

    v_out = zeros(size(theta));
    v_out(on) = v_conv(on);

    Vavg(k) = mean(v_out);
    Vout_rms(k) = sqrt(mean(v_out.^2));
    Iavg(k) = mean(i_t);
    Irms(k) = sqrt(mean(i_t.^2));

    % Power Loss Calculations
    P_batt(k) = Irms(k)^2 * Rbat;
    
    if ~(Ileak == 0)
        P_thyristor(k) = Vt*Iavg(k) + Rth*Irms(k)^2;
    end
    
    if Ileak > 0
        v_blocking = V_source;
        v_blocking(on) = 0;  % Zero when conducting
        P_blocking(k) = mean(v_blocking) * Ileak;
    else
        P_blocking(k) = 0;
    end
    
    if (t_rise > 0 || t_fall > 0) && Irms(k) > 0
        I_peak = max(i_t);
        V_block_avg = mean(V_source(~on));
        if isnan(V_block_avg)
            V_block_avg = Vm;
        end
        E_on = (1/6) * V_block_avg * I_peak * t_rise;
        E_off = (1/6) * V_block_avg * I_peak * t_fall;
        P_switching(k) = f * (E_on + E_off);
    else
        P_switching(k) = 0;
    end
    
    P_total(k) = P_batt(k) + P_thyristor(k) + P_blocking(k) + P_switching(k);
    P_loss_avg(k) = P_thyristor(k);

    if isempty(t_charge) || isinf(t_charge)
        dSoC = max(SoC_target - SoC_init, 0)/100; 
        if Iavg(k) > 0
            t_sec = (Q_C * dSoC) / Iavg(k);
        else
            t_sec = inf;
        end
        charging_time_hours(k) = t_sec/3600;
        SoC_final(k) = SoC_target;
    else
        t_sec = t_charge;
        SoC_final(k) = min(100, SoC_init + 100*(Iavg(k)*t_sec)/Q_C);
        charging_time_hours(k) = t_sec/3600;
    end
end

metrics = struct('Vavg', Vavg, 'Vrms', Vout_rms, 'Iavg', Iavg, 'Irms', Irms, ...
                 'P_batt', P_batt, 'P_thyristor', P_thyristor, ...
                 'P_blocking', P_blocking, 'P_switching', P_switching, 'P_total', P_total);

[~, alpha_idx] = min(abs(alpha_deg - alpha));

% Create output directory if savePlots is enabled
if savePlots
    output_dir = fullfile(fileparts(mfilename('fullpath')), '..', 'figures', 'half_wave');
    if ~exist(output_dir, 'dir')
        mkdir(output_dir);
    end
end

% Plotting and display code follows...
% (Abbreviated for space - full implementation includes comprehensive plotting)

end
\end{lstlisting}

\subsection{Full-Wave Center-Tapped (full\_wave\_ct\_charger.m)}

\begin{lstlisting}[basicstyle=\ttfamily\tiny]
function [alpha_deg, charging_time_hours, SoC_final, P_loss_avg, metrics] = full_wave_ct_charger(Vrms, f, Vbat, Rbat, capacity, capUnit, varargin)
% Full-wave center-tapped rectifier - uses two thyristors
% Key difference from half-wave: V_abs = Vm * abs(sin(theta))
% Output frequency doubled (100 Hz ripple vs 50 Hz)
% Average voltage: Vdc = (2*Vm/pi) * (1 + cos(alpha)) - Vt

% Load workspace parameters
try SoC_target_ws = evalin('base', 'SoC_target'); catch, SoC_target_ws = 80; end
try t_charge_ws = evalin('base', 't_charge'); if isinf(t_charge_ws), t_charge_ws = []; end
catch, t_charge_ws = []; end
try alpha_deg_ws = evalin('base', 'alpha_deg'); catch, alpha_deg_ws = 0:5:175; end
try enablePlots_ws = evalin('base', 'enablePlots'); catch, enablePlots_ws = false; end
try savePlots_ws = evalin('base', 'savePlots'); catch, savePlots_ws = false; end
try Rth_ws = evalin('base', 'Rth'); catch, Rth_ws = 0; end
try alpha_ws = evalin('base', 'alpha'); catch, alpha_ws = 90; end
try SoC_init_ws = evalin('base', 'SoC_init'); catch, SoC_init_ws = 90; end

% Parse inputs
p = inputParser;
addParameter(p, 't_charge', t_charge_ws, @(x) isempty(x) || (isnumeric(x) && isscalar(x)));
addParameter(p, 'SoC_init', SoC_init_ws, @isnumeric);
addParameter(p, 'SoC_target', SoC_target_ws, @isnumeric);
addParameter(p, 'Vt', 0, @isnumeric);
addParameter(p, 'alpha_deg', alpha_deg_ws, @(x) isnumeric(x) && isvector(x));
addParameter(p, 'Rth', Rth_ws, @isnumeric);
addParameter(p, 'Ileak', 0, @isnumeric); 
addParameter(p, 't_rise', 0, @isnumeric); 
addParameter(p, 't_fall', 0, @isnumeric);
addParameter(p, 'alpha', alpha_ws, @isnumeric); 
addParameter(p, 'enablePlots', enablePlots_ws, @(x) islogical(x) || isnumeric(x));
addParameter(p, 'savePlots', savePlots_ws, @(x) islogical(x) || isnumeric(x));
parse(p, varargin{:});

t_charge = p.Results.t_charge; SoC_init = p.Results.SoC_init;
SoC_target = p.Results.SoC_target; Vt = p.Results.Vt;
alpha_deg = p.Results.alpha_deg; Rth = p.Results.Rth;
Ileak = p.Results.Ileak; t_rise = p.Results.t_rise; t_fall = p.Results.t_fall;
enablePlots = logical(p.Results.enablePlots); savePlots = logical(p.Results.savePlots);
alpha = p.Results.alpha;

if isstring(capUnit) || ischar(capUnit)
    if strcmpi(string(capUnit), "Wh"), capacity = capacity / Vbat; end
end
t_charge = t_charge*3600; % Hours to seconds

% Constants and sampling
Vm = sqrt(2) * Vrms;
N = 4096;
theta = linspace(0, 2*pi, N+1); theta(end) = [];
theta_mod = mod(theta, pi);
V_abs = Vm * abs(sin(theta)); % Full-wave rectification
Q_C = capacity * 3600;

% Initialize outputs
na = numel(alpha_deg);
Vavg = zeros(1, na); Vout_rms = zeros(1, na);
Iavg = zeros(1, na); Irms = zeros(1, na);
P_loss_avg = zeros(1, na); P_batt = zeros(1, na);
P_thyristor = zeros(1, na); P_blocking = zeros(1, na);
P_switching = zeros(1, na); P_total = zeros(1, na);
charging_time_hours = zeros(1, na); SoC_final = zeros(1, na);

for k = 1:na
    a = deg2rad(alpha_deg(k));
    gate = theta_mod >= a & theta_mod <= pi;
    v_conv = (V_abs - Vt);
    cond = v_conv > Vbat;
    
    i_t = zeros(size(theta));
    on = gate & cond;
    i_t(on) = (v_conv(on) - Vbat) ./ Rbat;
    
    v_out = zeros(size(theta));
    v_out(on) = v_conv(on);
    
    Vavg(k) = mean(v_out); Vout_rms(k) = sqrt(mean(v_out.^2));
    Iavg(k) = mean(i_t); Irms(k) = sqrt(mean(i_t.^2));
    
    % Power losses
    P_batt(k) = Irms(k)^2 * Rbat;
    if ~(Ileak == 0), P_thyristor(k) = Vt*Iavg(k) + Rth*Irms(k)^2; end
    if Ileak > 0
        v_blocking = V_abs; v_blocking(on) = 0;
        P_blocking(k) = mean(v_blocking) * Ileak;
    else, P_blocking(k) = 0; end
    
    if (t_rise > 0 || t_fall > 0) && Irms(k) > 0
        I_peak = max(i_t); V_block_avg = mean(V_abs(~on));
        if isnan(V_block_avg), V_block_avg = Vm; end
        E_on = (1/6) * V_block_avg * I_peak * t_rise;
        E_off = (1/6) * V_block_avg * I_peak * t_fall;
        P_switching(k) = f * (E_on + E_off);
    else, P_switching(k) = 0; end
    
    P_total(k) = P_batt(k) + P_thyristor(k) + P_blocking(k) + P_switching(k);
    P_loss_avg(k) = P_thyristor(k);

    % Calculate charging time or final SoC
    if isempty(t_charge) || isinf(t_charge)
        dSoC = max(SoC_target - SoC_init, 0)/100; 
        if Iavg(k) > 0, t_sec = (Q_C * dSoC) / Iavg(k);
        else, t_sec = inf; end
        charging_time_hours(k) = t_sec/3600;
        SoC_final(k) = SoC_target;
    else
        t_sec = t_charge;
        SoC_final(k) = min(100, SoC_init + 100*(Iavg(k)*t_sec)/Q_C);
        charging_time_hours(k) = t_sec/3600;
    end
end

metrics = struct('Vavg', Vavg, 'Vrms', Vout_rms, 'Iavg', Iavg, 'Irms', Irms, ...
                 'P_batt', P_batt, 'P_thyristor', P_thyristor, ...
                 'P_blocking', P_blocking, 'P_switching', P_switching, 'P_total', P_total);

[~, alpha_idx] = min(abs(alpha_deg - alpha));

% Create output directory
if savePlots
    output_dir = fullfile(fileparts(mfilename('fullpath')), '..', 'figures', 'full_wave_ct');
    if ~exist(output_dir, 'dir'), mkdir(output_dir); end
end

% Plotting code similar to half_wave_charger follows...
% (Abbreviated for space - includes voltage/current/loss plots)

end
\end{lstlisting}

\subsection{Full-Wave Bridge (full\_wave\_bridge\_charger.m)}

\begin{lstlisting}[basicstyle=\ttfamily\tiny]
function [alpha_deg, charging_time_hours, SoC_vec, P_loss_vec] = full_wave_bridge_charger(Vrms, f, Vbat, Rbat, capacity, capUnit, varargin)
% FULL_WAVE_BRIDGE_CHARGER Analyzes full-wave bridge controlled rectifier
% Bridge configuration with 4 thyristors
% Two thyristor drops in series: Vdc = (2*Vm/pi)*(1+cos(alpha)) - 2*Vt

p = inputParser;
addParameter(p, 't_charge', inf, @isnumeric);
addParameter(p, 'SoC_init', 20, @isnumeric);
addParameter(p, 'Vt', 0, @isnumeric);
addParameter(p, 'Ileak', 0, @isnumeric);
addParameter(p, 't_rise', 0, @isnumeric);
addParameter(p, 't_fall', 0, @isnumeric);
addParameter(p, 'alpha_given', [], @isnumeric);
parse(p, varargin{:});

t_charge = p.Results.t_charge;
SoC_init = p.Results.SoC_init;
Vt = p.Results.Vt;
Ileak = p.Results.Ileak;

Vm = sqrt(2) * Vrms;
omega = 2 * pi * f;

alpha_deg = 0:5:150;
alpha_rad = deg2rad(alpha_deg);

switch lower(string(capUnit))
    case "ah"
        Q_tot = capacity * 3600;
    case "wh"
        E_tot = capacity * 3600;
        Q_tot = E_tot / Vbat;
    otherwise
        error('capUnit must be ''Ah'' or ''Wh''.');
end

SoC_target = 80;
Q_init = (SoC_init/100) * Q_tot;

nAlpha = numel(alpha_deg);
charging_time_hours = nan(1, nAlpha);
SoC_vec = nan(1, nAlpha);
P_loss_vec = nan(1, nAlpha);

nonideal_SCR = ~all(ismember({'Vt','Ileak','t_rise','t_fall'}, p.UsingDefaults));

for k = 1:nAlpha
    alpha = alpha_rad(k);
    Vdc_ideal = (Vm/pi) * (1+cos(alpha));
    Vdc_eff = Vdc_ideal - 2*Vt;  % Two thyristor drops
    I_charge = (Vdc_eff - Vbat) / Rbat;
    
    if I_charge <= 0 || Vdc_eff <= Vbat
        charging_time_hours(k) = Inf;
        if nonideal_SCR
            P_loss_vec(k) = Vrms * Ileak;
        else
            P_loss_vec(k) = 0;
        end
        continue;
    end

    if isinf(t_charge)
        dSoC = SoC_target - SoC_init;
        if dSoC <= 0
            t_req = 0;
            SoC_vec(k) = SoC_init;
        else
            dQ = (dSoC/100) * Q_tot;
            t_req = dQ / I_charge;
            SoC_vec(k) = SoC_target;
        end
        charging_time_hours(k) = t_req / 3600;
    else
        dQ = I_charge * t_charge;
        SoC_f = SoC_init + 100 * (dQ / Q_tot);
        SoC_f = min(max(SoC_f, 0), 100);
        SoC_vec(k) = SoC_f;
        
        dQ_req = (SoC_target - SoC_init)/100 * Q_tot;
        if dQ_req <= 0
            t_req = 0;
        else
            t_req = dQ_req / I_charge;
        end
        charging_time_hours(k) = t_req / 3600;
    end

    if nonideal_SCR
        P_cond = 2 * Vt * I_charge;
        P_leak = Vrms * Ileak;
        P_loss_vec(k) = P_cond + P_leak;
    else
        P_loss_vec(k) = 0;
    end
end

% Generate output plots
figure('Name', 'Full-Wave Bridge Rectifier - Firing Angle vs Charging Time');
plot(alpha_deg, charging_time_hours, 'g-d', 'LineWidth', 2);
grid on;
xlabel('Firing Angle \alpha (degrees)');
ylabel('Charging Time (hours)');
title('Full-Wave Bridge Controlled Rectifier for Battery Charging');
legend('Charging Time');

end
\end{lstlisting}

\newpage
\section{Load Analysis MATLAB Code}

This section contains the MATLAB implementation for the load analysis (Milestone 2) including parameter sweeps and automated Simulink simulation control.

\subsection{Load Analysis Parameters (params.m)}

\begin{lstlisting}
% Load Analysis Parameters

% Supply
Vrms = 230; 
f = 50;
alphas_deg = 0:5:180;            
simTime = 0.1;
T = 1/f;

% Load scenarios
scenarios = struct();
scenarios(1).name = 'resistive_only';
scenarios(1).R = 10;           % Resistance only (ohms)
scenarios(1).L = 1e-6;         % Minimal inductance (H)

scenarios(2).name = 'R_L_load';
scenarios(2).R = 10;           % Resistance (ohms)
scenarios(2).L = 50e-3;        % Moderate inductance (H)

scenarios(3).name = 'highly_inductive';
scenarios(3).R = 5;            % Lower resistance (ohms)
scenarios(3).L = 200e-3;       % High inductance (H)

% Pulse Generator parameters
pulse_amplitude = 10;           % Gate signal amplitude (V)
pulse_width = 50;              % Pulse width (% of period)
pulse_period = 1/f;            % Period based on line frequency (s)

% Model selection: 'all', 'ct', 'bg', 'hf', or cell array {'ct', 'bg'}
% 'ct' = center_taped, 'bg' = bridge (Full_Wave_Bridge), 'hf' = half_wave
modelSelection = 'ct';        

% Live plotting option
enableLivePlot = false;  

% Graph generation option
generateGraphs = true;   
graphAlphas = [30, 90, 180];  % Alpha values to plot (degrees)

R = 30;
L = 0.1;

phase_delay = 0.005;
phase_delay2 = 0.015;
\end{lstlisting}

\subsection{Load Analysis Sweep Script (load\_analysis\_sweep.m)}

\begin{lstlisting}[basicstyle=\ttfamily\tiny]
run params.m

% Close all open Simulink models
bd = find_system('type', 'block_diagram');
for i = 1:length(bd)
    if ~strcmp(bd{i}, 'simulink')
        try
            close_system(bd{i}, 0);
        catch
        end
    end
end

% Setup directories
saveFolder = fullfile(fileparts(mfilename('fullpath')),'results');
if ~exist(saveFolder,'dir')
    mkdir(saveFolder);
end

scriptDir = fileparts(mfilename('fullpath'));
slxDir = fullfile(scriptDir,'..','simulink');
files = dir(fullfile(slxDir,'*.slx'));
if isempty(files)
    error('No .slx models found in %s', slxDir);
end

models = {files.name};

% Filter models based on selection
if ~strcmp(modelSelection, 'all')
    modelMap = struct('ct', 'center_taped', 'bg', 'Full_Wave_Bridge', 'hf', 'half_wave');
    
    if ischar(modelSelection)
        if isfield(modelMap, modelSelection)
            targetName = modelMap.(modelSelection);
            models = models(contains(lower(models), lower(targetName)));
        else
            error('Invalid modelSelection: %s', modelSelection);
        end
    elseif iscell(modelSelection)
        selectedModels = {};
        for i = 1:length(modelSelection)
            sel = modelSelection{i};
            if isfield(modelMap, sel)
                targetName = modelMap.(sel);
                selectedModels = [selectedModels; models(contains(lower(models), lower(targetName)))];
            end
        end
        models = unique(selectedModels);
    end
end

fprintf('Found %d model(s):\n', numel(models));
for k=1:numel(models)
    fprintf(' - %s\n', models{k});
end

fprintf('\nLoad scenarios:\n');
for s=1:numel(scenarios)
    fprintf(' %d. %s: R=%.2f Ohm, L=%.1f mH\n', s, scenarios(s).name, scenarios(s).R, scenarios(s).L*1000);
end

if enableLivePlot
    figHandle = figure('Name', 'Live Waveforms', 'NumberTitle', 'off');
end

results = struct();

% Main sweep loop
for si = 1:numel(scenarios)
    scenario = scenarios(si);
    fprintf('\n========== Scenario %d: %s ==========\n', si, scenario.name);
    
    for mi = 1:numel(models)
        modelName = models{mi};
        modelPath = fullfile(slxDir, modelName);
        [~,modelBase] = fileparts(modelName);
        
        fprintf('\nRunning model: %s\n', modelName);
        
        % Close existing instance if loaded
        if bdIsLoaded(modelBase)
            fprintf('  Closing existing model instance...\n');
            try
                simStatus = get_param(modelBase, 'SimulationStatus');
                if ~strcmp(simStatus, 'stopped')
                    set_param(modelBase, 'SimulationCommand', 'stop');
                    pause(1);
                end
            catch ME
                warning('Error stopping simulation: %s', ME.message);
            end
            
            try
                close_system(modelBase, 0);
            catch ME
                warning('Could not close model: %s', ME.message);
            end
        end
        
        load_system(modelPath);
        modelResults = cell(numel(alphas_deg),1);
        
        % Alpha sweep
        for ai = 1:numel(alphas_deg)
            alpha_deg = alphas_deg(ai);
            phase_delay = (alpha_deg/360) * (1/f);
            phase_delay2 = phase_delay + (1/(2*f));
            
            % Assign parameters to base workspace
            assignin('base','alpha_deg',alpha_deg);
            assignin('base','phase_delay',phase_delay);
            assignin('base','f',f);
            assignin('base','Vrms',Vrms);
            assignin('base','R',scenario.R);
            assignin('base','L',scenario.L);
            assignin('base','pulse_amplitude',pulse_amplitude);
            assignin('base','pulse_width',pulse_width);
            assignin('base','pulse_period',pulse_period);
            
            evalin('base', 'clear Vout Iout V_data I_data vout iout');
            
            fprintf('  alpha = %3d deg ... ', alpha_deg);
            
            try
                simOut = sim(modelBase, 'StopTime', num2str(simTime), ...
                    'SaveOutput','on', 'SaveTime','on', 'ReturnWorkspaceOutputs','on');
            catch ME
                fprintf('FAILED\n');
                warning('Simulation failed: %s', ME.message);
                modelResults{ai} = struct('alpha_deg',alpha_deg,'error',ME);
                continue
            end
            
            fprintf('OK\n');
            
            % Store results
            entry.alpha_deg = alpha_deg;
            entry.phase_delay = phase_delay;
            entry.R = scenario.R;
            entry.L = scenario.L;
            entry.simOut = simOut;
            
            % Extract voltage and current data
            try
                V_data = []; I_data = []; t_data = simOut.tout;
                
                % Try to get data from simulation output
                if isprop(simOut, 'Vout') && isprop(simOut, 'Iout')
                    Vout = simOut.Vout;
                    Iout = simOut.Iout;
                    
                    if isa(Vout, 'timeseries')
                        V_data = Vout.Data;
                        t_data = Vout.Time;
                    elseif isnumeric(Vout)
                        V_data = Vout(:);
                    end
                    
                    if isa(Iout, 'timeseries')
                        I_data = Iout.Data;
                    elseif isnumeric(Iout)
                        I_data = Iout(:);
                    end
                end
                
                % Calculate metrics
                if ~isempty(V_data) && ~isempty(I_data)
                    entry.Vavg = mean(V_data);
                    entry.Vrms = sqrt(mean(V_data.^2));
                    entry.Iavg = mean(I_data);
                    entry.Irms = sqrt(mean(I_data.^2));
                    
                    % Live plotting
                    if enableLivePlot && mod(ai, 6) == 1
                        figure(figHandle);
                        subplot(2,1,1);
                        plot(t_data, V_data, 'b-', 'LineWidth', 1.5);
                        xlabel('Time (s)'); ylabel('Voltage (V)');
                        title(sprintf('%s - %s: alpha=%d deg', modelBase, scenario.name, alpha_deg));
                        grid on;
                        
                        subplot(2,1,2);
                        plot(t_data, I_data, 'r-', 'LineWidth', 1.5);
                        xlabel('Time (s)'); ylabel('Current (A)');
                        title(sprintf('Current at alpha=%d deg', alpha_deg));
                        grid on;
                        drawnow;
                    end
                else
                    entry.Vavg = NaN; entry.Vrms = NaN;
                    entry.Iavg = NaN; entry.Irms = NaN;
                end
            catch ME
                warning('Error extracting data: %s', ME.message);
                entry.Vavg = NaN; entry.Vrms = NaN;
                entry.Iavg = NaN; entry.Irms = NaN;
            end
            
            modelResults{ai} = entry;
        end
        
        % Save results
        fieldName = sprintf('%s_%s', modelBase, scenario.name);
        results.(fieldName) = modelResults;
        saveFile = fullfile(saveFolder, sprintf('%s_%s_results.mat', modelBase, scenario.name));
        save(saveFile, 'modelResults','scenario','-v7.3');
        fprintf('Saved results to %s\n', saveFile);
        
        % Print summary
        fprintf('\nSummary for %s - %s:\n', modelName, scenario.name);
        fprintf('  Alpha(deg)  Vavg(V)   Vrms(V)   Iavg(A)   Irms(A)\n');
        fprintf('  -----------------------------------------------\n');
        for ai = 1:min(5, numel(modelResults))
            if ~isempty(modelResults{ai}) && isfield(modelResults{ai}, 'Vavg')
                e = modelResults{ai};
                fprintf('  %6d     %7.2f   %7.2f   %7.3f   %7.3f\n', ...
                    e.alpha_deg, e.Vavg, e.Vrms, e.Iavg, e.Irms);
            end
        end
        
        % Generate graphs for selected alpha values
        if generateGraphs
            fprintf('\nGenerating graphs...\n');
            figFolder = fullfile(saveFolder, '..', '..', 'figures', modelBase, scenario.name);
            if ~exist(figFolder, 'dir')
                mkdir(figFolder);
            end
            
            for alpha_val = graphAlphas
                resultIdx = -1;
                for ai = 1:numel(modelResults)
                    if ~isempty(modelResults{ai}) && modelResults{ai}.alpha_deg == alpha_val
                        resultIdx = ai;
                        break;
                    end
                end
                
                if resultIdx > 0 && isfield(modelResults{resultIdx}, 'simOut')
                    result = modelResults{resultIdx};
                    simOut = result.simOut;
                    
                    % Extract plot data
                    if isprop(simOut, 'Vout') && isprop(simOut, 'Iout')
                        VoutData = simOut.Vout;
                        IoutData = simOut.Iout;
                        
                        if isa(VoutData, 'timeseries')
                            V_plot = VoutData.Data;
                            t_plot = VoutData.Time;
                        else
                            V_plot = VoutData(:);
                            t_plot = simOut.tout;
                        end
                        
                        if isa(IoutData, 'timeseries')
                            I_plot = IoutData.Data;
                        else
                            I_plot = IoutData(:);
                        end
                        
                        % Create figure
                        fig = figure('Position', [100, 100, 1200, 600]);
                        
                        subplot(2, 1, 1);
                        plot(t_plot, V_plot, 'b-', 'LineWidth', 1.5);
                        grid on;
                        xlabel('Time (s)'); ylabel('Voltage (V)');
                        title(sprintf('%s - %s: Voltage (alpha = %d deg)', ...
                            strrep(modelBase, '_', ' '), strrep(scenario.name, '_', ' '), alpha_val));
                        
                        subplot(2, 1, 2);
                        plot(t_plot, I_plot, 'r-', 'LineWidth', 1.5);
                        grid on;
                        xlabel('Time (s)'); ylabel('Current (A)');
                        title(sprintf('Current (alpha = %d deg)', alpha_val));
                        
                        % Save figure
                        figName = sprintf('%s_%s_alpha_%d', modelBase, scenario.name, alpha_val);
                        saveas(fig, fullfile(figFolder, [figName '.png']));
                        saveas(fig, fullfile(figFolder, [figName '.fig']));
                        fprintf('  Saved graph for alpha=%d\n', alpha_val);
                        close(fig);
                    end
                end
            end
        end
        
        try
            close_system(modelPath,0);
        catch
        end
    end
end

% Save all results
save(fullfile(saveFolder,'all_results.mat'),'results','-v7.3');
fprintf('\nAll sweeps finished. Results in: %s\n', saveFolder);
\end{lstlisting}

\newpage
\section{Simulink Models}

The following Simulink models were developed for load analysis simulations:

\subsection{Rectifier Configuration Models}

\begin{enumerate}
    \item \texttt{center\_taped.slx} - Center-tapped full-wave rectifier with thyristor control
    \item \texttt{Full\_Wave\_Bridge.slx} - Full-wave bridge rectifier with four thyristors
    \item \texttt{half\_wave.slx} - Half-wave controlled rectifier with single thyristor
\end{enumerate}

\subsection{Diode Reference Models}

\begin{enumerate}
    \item \texttt{ct\_diode.slx} - Center-tapped rectifier with diodes (uncontrolled)
    \item \texttt{fw\_diode.slx} - Full-wave bridge with diodes (uncontrolled)
    \item \texttt{hf\_diode.slx} - Half-wave rectifier with diode (uncontrolled)
\end{enumerate}

All Simulink models are located in the \texttt{load\_analysis/simulink/} directory and implement various load scenarios including resistive-only, R-L, and highly inductive loads. The models support automated parameter sweeps through the MATLAB script interface for comprehensive analysis of rectifier performance across different firing angles and load conditions.

\newpage
\subsection{Simulink/Simscape Circuit Diagrams}

The following figures show the Simscape implementation of the controlled rectifier circuits used in the load analysis simulations.

\subsubsection{Center-Tapped Full-Wave Rectifier}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{Load_Analysis/CT/CTSIMULINK.png}
    \caption{Center-tapped full-wave controlled rectifier Simscape model. The circuit uses two thyristors with phase-shifted gate signals to achieve full-wave rectification. A center-tapped transformer provides the dual voltage sources required for this topology.}
    \label{fig:ct_simulink}
\end{figure}

\subsubsection{Full-Wave Bridge Rectifier}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{Load_Analysis/BG/bgSimulink.jpeg}
    \caption{Full-wave bridge controlled rectifier Simscape model. The circuit employs four thyristors arranged in a bridge configuration, allowing for full-wave rectification without requiring a center-tapped transformer. Gate signals are synchronized to control the firing angles of thyristor pairs.}
    \label{fig:bg_simulink}
\end{figure}

\subsubsection{Half-Wave Rectifier}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{Load_Analysis/HF/hfSimulink.jpeg}
    \caption{Half-wave controlled rectifier Simscape model. This simplified topology uses a single thyristor to control current flow during the positive half-cycle of the AC input. The circuit demonstrates the basic principles of phase-controlled rectification.}
    \label{fig:hf_simulink}
\end{figure}

\end{document}
